<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>zsig: include/zpolbasist.hh Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">zsig&#160;<span id="projectnumber">1.0.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('zpolbasist_8hh.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>include/zpolbasist.hh</h1>  </div>
</div>
<div class="contents">
<a href="zpolbasist_8hh.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="preprocessor">#ifndef ZSIG_ZPOLBASIST_HH</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span><span class="preprocessor">#define ZSIG_ZPOLBASIST_HH</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span>
<a name="l00011"></a>00011 <span class="comment">//== INCLUDES =================================================================</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">//== NAMESPACES ===============================================================</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">namespace </span>zsig {
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">//=== IMPLEMENTATION ==========================================================</span>
<a name="l00023"></a>00023 
<a name="l00032"></a>00032 <span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;
<a name="l00033"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a72671dd3a9e2d20f434c5c2c87405ef1">00033</a> T <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a72671dd3a9e2d20f434c5c2c87405ef1" title="Compute factorial of n: .">fac</a>( <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; _n ) {
<a name="l00034"></a>00034         T f = (T)1;
<a name="l00035"></a>00035         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 2; i &lt;= _n; ++i) f *= i;
<a name="l00036"></a>00036         <span class="keywordflow">return</span> f;
<a name="l00037"></a>00037 }
<a name="l00038"></a>00038 
<a name="l00060"></a>00060 <span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;
<a name="l00061"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aed020103343d1c0210cc929069b07559">00061</a> T compute_R( <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _p,
<a name="l00062"></a>00062              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; _q,
<a name="l00063"></a>00063              <span class="keyword">const</span> T&amp; _r ) {
<a name="l00064"></a>00064 
<a name="l00065"></a>00065         <span class="keywordtype">int</span> a, b, c, d;
<a name="l00066"></a>00066         T sum = (T)0;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = (_q&lt;0?-_q:_q); k &lt;= _p; k += 2) {
<a name="l00069"></a>00069 
<a name="l00070"></a>00070                 a = (_p - k) / 2; b = (_p + k) / 2;
<a name="l00071"></a>00071                 c = (k - _q) / 2; d = (k + _q) / 2;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073                 sum += ( ( pow( (T)-1.0, (T)a ) * fac&lt;T&gt;(b) ) /
<a name="l00074"></a>00074                          ( fac&lt;T&gt;(a) * fac&lt;T&gt;(c) * fac&lt;T&gt;(d) ) ) * pow( _r, (T)k );
<a name="l00075"></a>00075 
<a name="l00076"></a>00076         }
<a name="l00077"></a>00077 
<a name="l00078"></a>00078         <span class="keywordflow">return</span> sum;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 }
<a name="l00081"></a>00081 
<a name="l00101"></a>00101 <span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;
<a name="l00102"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a407b805297a8157b3e4d47281f1bcaff">00102</a> std::complex&lt; T &gt; compute_V( <span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _p,
<a name="l00103"></a>00103                              <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; _q,
<a name="l00104"></a>00104                              <span class="keyword">const</span> T&amp; _r,
<a name="l00105"></a>00105                              <span class="keyword">const</span> T&amp; _t ) {
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="keywordflow">return</span> std::polar( compute_R&lt;T&gt;( _p, _q, _r), _q * _t );
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">//== CLASS DEFINITION =========================================================</span>
<a name="l00112"></a>00112 
<a name="l00161"></a>00161 <span class="keyword">template</span>&lt; <span class="keywordtype">unsigned</span> Order = 8, <span class="keyword">class</span> T = <span class="keywordtype">long</span> <span class="keywordtype">double</span> &gt;
<a name="l00162"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html">00162</a> <span class="keyword">class </span><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">ZernikePolynomialsBasisT</a> {
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="keyword">public</span>:
<a name="l00165"></a>00165 
<a name="l00166"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a05b99b289230f11495b77913b042c8ca">00166</a>         <span class="keyword">typedef</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">ZernikePolynomialsBasisT&lt; Order, T &gt;</a> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a05b99b289230f11495b77913b042c8ca" title="This class type.">zpolbasis_type</a>; 
<a name="l00167"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59">00167</a>         <span class="keyword">typedef</span> std::complex&lt; T &gt; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a>; 
<a name="l00168"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a4b199b40b343b7451c043c7375da5ee1">00168</a>         <span class="keyword">typedef</span> std::vector&lt; value_type &gt; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a4b199b40b343b7451c043c7375da5ee1" title="Radial polynomial.">radial_polynomial</a>; 
<a name="l00169"></a>00169 
<a name="l00176"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a214ad8861d4f318e10b7a3098ff9057e">00176</a>         <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a214ad8861d4f318e10b7a3098ff9057e" title="Default Constructor.">ZernikePolynomialsBasisT</a>() : pol(Order+1) {
<a name="l00177"></a>00177                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) pol[p].resize( 1+p/2 );
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179 
<a name="l00186"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">00186</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( T **_fxy,
<a name="l00187"></a>00187                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00188"></a>00188                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy ) {
<a name="l00189"></a>00189                 <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( (<span class="keyword">const</span> T **)_fxy, _szx, _szy );
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00199"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a0925687fb6a1c9f7fe6b22f4592fe96d">00199</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( T **_fxy,
<a name="l00200"></a>00200                       <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **_zpb,
<a name="l00201"></a>00201                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00202"></a>00202                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy ) {
<a name="l00203"></a>00203                 <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( (<span class="keyword">const</span> T **)_fxy, (<span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **)_zpb, _szx, _szy );
<a name="l00204"></a>00204         }
<a name="l00205"></a>00205 
<a name="l00217"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a3cdbccd97f083e952bcdc7640718f52f">00217</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( <span class="keyword">const</span> T **_fxy,
<a name="l00218"></a>00218                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00219"></a>00219                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy ) {
<a name="l00220"></a>00220                 T x, y, r, t; <span class="comment">// (x, y) cartesian and (r, t) polar coordinates</span>
<a name="l00221"></a>00221                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00222"></a>00222                         T p1pi = (p + 1) / M_PI; <span class="comment">// frac outside summation</span>
<a name="l00223"></a>00223                         <span class="keywordtype">int</span> qi = 0; <span class="comment">// q index: q[0, 2, 4] -&gt; qi[0, 1, 2]</span>
<a name="l00224"></a>00224                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = p % 2; q &lt;= p; q += 2, qi++) {
<a name="l00225"></a>00225                                 pol[p][qi] = <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a>();
<a name="l00226"></a>00226                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gx = 0; gx &lt; _szx; ++gx) {
<a name="l00227"></a>00227                                         x = ( (T)2 * gx + (T)1 ) / (T)_szx - (T)1;
<a name="l00228"></a>00228                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gy = 0; gy &lt; _szy; ++gy) {
<a name="l00229"></a>00229                                                 y = ( (T)2 * gy + (T)1 ) / (T)_szy - (T)1;
<a name="l00230"></a>00230                                                 r = (T)sqrt( x*x + y*y );
<a name="l00231"></a>00231                                                 <span class="keywordflow">if</span>( r &gt; (T)1 ) <span class="keywordflow">continue</span>; <span class="comment">// outside unit circle is zero</span>
<a name="l00232"></a>00232                                                 t = (T)atan2( y, x );
<a name="l00233"></a>00233                                                 pol[p][qi] += std::conj( <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a407b805297a8157b3e4d47281f1bcaff" title="Compute Zernike Polynomial: .">compute_V</a>(p, q, r, t) ) * _fxy[gx][gy];
<a name="l00234"></a>00234                                         } <span class="comment">// gy</span>
<a name="l00235"></a>00235                                 } <span class="comment">// gx</span>
<a name="l00236"></a>00236                                 pol[p][qi] *= p1pi;
<a name="l00237"></a>00237                         } <span class="comment">// q</span>
<a name="l00238"></a>00238                 } <span class="comment">// p</span>
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240 
<a name="l00271"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#abf9403a1fe296638542132488c8c7187">00271</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#aba8cb52c2e02043ec97114c7ad7f9041">project</a>( <span class="keyword">const</span> T **_fxy,
<a name="l00272"></a>00272                       <span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **_zpb,
<a name="l00273"></a>00273                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00274"></a>00274                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy ) {
<a name="l00275"></a>00275                 T x, y, r; <span class="comment">// (x, y) cartesian coordinates and radius r</span>
<a name="l00276"></a>00276                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00277"></a>00277                         T p1pi = (p + 1) / M_PI; <span class="comment">// frac outside summation</span>
<a name="l00278"></a>00278                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qi = 0; qi &lt;= p/2; ++qi) {
<a name="l00279"></a>00279                                 pol[p][qi] = <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a>();
<a name="l00280"></a>00280                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gx = 0; gx &lt; _szx; ++gx) {
<a name="l00281"></a>00281                                         x = ( (T)2 * gx + (T)1 ) / (T)_szx - (T)1;
<a name="l00282"></a>00282                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gy = 0; gy &lt; _szy; ++gy) {
<a name="l00283"></a>00283                                                 y = ( (T)2 * gy + (T)1 ) / (T)_szy - (T)1;
<a name="l00284"></a>00284                                                 r = (T)sqrt( x*x + y*y );
<a name="l00285"></a>00285                                                 <span class="keywordflow">if</span>( r &gt; (T)1 ) <span class="keywordflow">continue</span>; <span class="comment">// outside unit circle is zero</span>
<a name="l00286"></a>00286                                                 pol[p][qi] += std::conj( _zpb[gx][gy][p][qi] ) * _fxy[gx][gy];
<a name="l00287"></a>00287                                         } <span class="comment">// gy</span>
<a name="l00288"></a>00288                                 } <span class="comment">// gx</span>
<a name="l00289"></a>00289                                 pol[p][qi] *= p1pi;
<a name="l00290"></a>00290                         } <span class="comment">// qi</span>
<a name="l00291"></a>00291                 } <span class="comment">// p</span>
<a name="l00292"></a>00292         }
<a name="l00293"></a>00293 
<a name="l00301"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a62ba4a56669768b02abee187a5d2f1eb">00301</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a62ba4a56669768b02abee187a5d2f1eb">reconstruct</a>( T **_fxy,
<a name="l00302"></a>00302                           <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **_zpb,
<a name="l00303"></a>00303                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00304"></a>00304                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy )<span class="keyword"> const </span>{
<a name="l00305"></a>00305                 <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a62ba4a56669768b02abee187a5d2f1eb">reconstruct</a>( _fxy, (<span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **)_zpb, _szx, _szy );
<a name="l00306"></a>00306         }
<a name="l00307"></a>00307 
<a name="l00318"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a0ce02089d49b0dff9add1131ed78e2e0">00318</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a62ba4a56669768b02abee187a5d2f1eb">reconstruct</a>( T **_fxy,
<a name="l00319"></a>00319                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00320"></a>00320                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy )<span class="keyword"> const </span>{
<a name="l00321"></a>00321                 T x, y, r, t; <span class="comment">// (x, y) cartesian and (r, t) polar coordinates</span>
<a name="l00322"></a>00322                 <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a> rv, zpV; <span class="comment">// reconstructed value and Zernike Polynomial V</span>
<a name="l00323"></a>00323                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gx = 0; gx &lt; _szx; ++gx) {
<a name="l00324"></a>00324                         x = ( (T)2 * gx + (T)1 ) / (T)_szx - (T)1;
<a name="l00325"></a>00325                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gy = 0; gy &lt; _szy; ++gy) {
<a name="l00326"></a>00326                                 y = ( (T)2 * gy + (T)1 ) / (T)_szy - (T)1;
<a name="l00327"></a>00327                                 r = (T)sqrt( x*x + y*y );
<a name="l00328"></a>00328                                 rv = <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a>();
<a name="l00329"></a>00329                                 <span class="keywordflow">if</span>( r &lt;= (T)1 ) { <span class="comment">// reconstruct inside unit circle only</span>
<a name="l00330"></a>00330                                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00331"></a>00331                                                 <span class="keywordtype">int</span> qi = 0; <span class="comment">// q index: q[0, 2, 4] -&gt; qi[0, 1, 2]</span>
<a name="l00332"></a>00332                                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = p % 2; q &lt;= p; q += 2, qi++) {
<a name="l00333"></a>00333                                                         t = (T)atan2( y, x );
<a name="l00334"></a>00334                                                         zpV = <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a407b805297a8157b3e4d47281f1bcaff" title="Compute Zernike Polynomial: .">compute_V</a>(p, q, r, t);
<a name="l00335"></a>00335                                                         rv += pol[p][qi] * zpV; <span class="comment">// using +q</span>
<a name="l00336"></a>00336                                                         <span class="keywordflow">if</span>( p % 2 != 0 or qi != 0 ) <span class="comment">// for p even and q zero z does not repeat itself</span>
<a name="l00337"></a>00337                                                                 rv += std::conj( pol[p][qi] ) * std::conj( zpV ); <span class="comment">// using -q</span>
<a name="l00338"></a>00338                                                 } <span class="comment">// q</span>
<a name="l00339"></a>00339                                         } <span class="comment">// p</span>
<a name="l00340"></a>00340                                 } <span class="comment">// if</span>
<a name="l00341"></a>00341                                 _fxy[gx][gy] = rv.real();
<a name="l00342"></a>00342                         } <span class="comment">// gy</span>
<a name="l00343"></a>00343                 } <span class="comment">// gx</span>
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345 
<a name="l00359"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a94f98e39b4bf663f6386027a9f6c1983">00359</a>         <span class="keywordtype">void</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a62ba4a56669768b02abee187a5d2f1eb">reconstruct</a>( T **_fxy,
<a name="l00360"></a>00360                           <span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a> **_zpb,
<a name="l00361"></a>00361                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00362"></a>00362                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy )<span class="keyword"> const </span>{
<a name="l00363"></a>00363                 <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a> rv; <span class="comment">// reconstructed value</span>
<a name="l00364"></a>00364                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gx = 0; gx &lt; _szx; ++gx) {
<a name="l00365"></a>00365                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> gy = 0; gy &lt; _szy; ++gy) {
<a name="l00366"></a>00366                                 rv = <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab95fd66256ec93a9cbeafc4304362a59" title="Polynomial value type.">value_type</a>();
<a name="l00367"></a>00367                                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00368"></a>00368                                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qi = 0; qi &lt;= p/2; ++qi) {
<a name="l00369"></a>00369                                                 rv += pol[p][qi] * _zpb[gx][gy][p][qi]; <span class="comment">// using +q</span>
<a name="l00370"></a>00370                                                 <span class="keywordflow">if</span>( p % 2 != 0 or qi != 0 ) <span class="comment">// for p even and q zero z does not repeat itself</span>
<a name="l00371"></a>00371                                                         rv += std::conj( pol[p][qi] ) * std::conj( _zpb[gx][gy][p][qi] ); <span class="comment">// using -q</span>
<a name="l00372"></a>00372                                         } <span class="comment">// qi</span>
<a name="l00373"></a>00373                                 } <span class="comment">// p</span>
<a name="l00374"></a>00374                                 _fxy[gx][gy] = rv.real();
<a name="l00375"></a>00375                         } <span class="comment">// gy</span>
<a name="l00376"></a>00376                 } <span class="comment">// gx</span>
<a name="l00377"></a>00377         }
<a name="l00378"></a>00378 
<a name="l00390"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ae510a8b57076008533e7fcba1545b3c6">00390</a>         T <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ae510a8b57076008533e7fcba1545b3c6" title="Compare two Zernike polynomials representations.">compare</a>( <span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a>&amp; _zp )<span class="keyword"> const </span>{
<a name="l00391"></a>00391                 T dist = (T)0; <span class="comment">// distance</span>
<a name="l00392"></a>00392                 T modz[2]; <span class="comment">// modulus of z</span>
<a name="l00393"></a>00393                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00394"></a>00394                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> qi = 0; qi &lt;= p/2; ++qi) {
<a name="l00395"></a>00395                                 modz[0] = std::abs( pol[p][qi] );
<a name="l00396"></a>00396                                 modz[1] = std::abs( _zp[p][qi] );
<a name="l00397"></a>00397                                 dist += (modz[0] - modz[1] ) * (modz[0] - modz[1] );
<a name="l00398"></a>00398                         } <span class="comment">// qi</span>
<a name="l00399"></a>00399                 } <span class="comment">// p</span>
<a name="l00400"></a>00400                 <span class="keywordflow">return</span> sqrt( dist );
<a name="l00401"></a>00401         }
<a name="l00402"></a>00402 
<a name="l00408"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab761e245a9889fde7de72037b529fdb7">00408</a>         <span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a4b199b40b343b7451c043c7375da5ee1" title="Radial polynomial.">radial_polynomial</a>&amp; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab761e245a9889fde7de72037b529fdb7" title="Read/write operator of each radial polynomial.">operator[] </a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _p)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;pol[_p]; }
<a name="l00409"></a>00409 
<a name="l00415"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a5fee0a37e91bbad470f9e9f2e1d01f9a">00415</a>         <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a4b199b40b343b7451c043c7375da5ee1" title="Radial polynomial.">radial_polynomial</a>&amp; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#ab761e245a9889fde7de72037b529fdb7" title="Read/write operator of each radial polynomial.">operator[] </a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span>&amp; _p) { <span class="keywordflow">return</span> this-&gt;pol[_p]; }
<a name="l00416"></a>00416 
<a name="l00423"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a16e900fb79af142ae4b65b1b7a0c5802">00423</a>         <span class="keyword">friend</span> std::istream&amp; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a16e900fb79af142ae4b65b1b7a0c5802" title="Input stream operator.">operator &gt;&gt; </a>(std::istream&amp; in, <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a>&amp; _z) {
<a name="l00424"></a>00424                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p)
<a name="l00425"></a>00425                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> qi = 0; qi &lt;= p/2; ++qi)
<a name="l00426"></a>00426                                 in &gt;&gt; _z[p][qi];
<a name="l00427"></a>00427                 <span class="keywordflow">return</span> in;
<a name="l00428"></a>00428         }
<a name="l00429"></a>00429 
<a name="l00436"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a9d42337c8ce1a6a1d19bfc2baf012366">00436</a>         <span class="keyword">friend</span> std::ostream&amp; <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a9d42337c8ce1a6a1d19bfc2baf012366" title="Output stream operator.">operator &lt;&lt; </a>(std::ostream&amp; out, <span class="keyword">const</span> <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">zpolbasis_type</a>&amp; _z) {
<a name="l00437"></a>00437                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> p = 0; p &lt;= Order; ++p) {
<a name="l00438"></a>00438                         out &lt;&lt; _z[p][0];
<a name="l00439"></a>00439                         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> qi = 1; qi &lt;= p/2; ++qi)
<a name="l00440"></a>00440                                 out &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; _z[p][qi];
<a name="l00441"></a>00441                 }
<a name="l00442"></a>00442                 <span class="keywordflow">return</span> out;
<a name="l00443"></a>00443         }
<a name="l00444"></a>00444 
<a name="l00445"></a>00445 <span class="keyword">private</span>:
<a name="l00446"></a>00446 
<a name="l00447"></a>00447         std::vector&lt; radial_polynomial &gt; pol; 
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 };
<a name="l00457"></a>00457 <span class="comment">//=== IMPLEMENTATION ==========================================================</span>
<a name="l00458"></a>00458 
<a name="l00490"></a>00490 <span class="keyword">template</span>&lt; <span class="keywordtype">unsigned</span> Order, <span class="keyword">class</span> T &gt;
<a name="l00491"></a><a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html#a2acab5e0bda03423004dc2a7f579ae69">00491</a> <span class="keywordtype">void</span> compute_basis( <a class="code" href="classzsig_1_1ZernikePolynomialsBasisT.html" title="Zernike Polynomials Orthogonal Basis type.">ZernikePolynomialsBasisT&lt; Order, T &gt;</a> **_zpb,
<a name="l00492"></a>00492                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szx,
<a name="l00493"></a>00493                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp; _szy ) {
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         T x, y, r, t; <span class="comment">// (x, y) cartesian and (r, t) polar coordinates</span>
<a name="l00496"></a>00496 
<a name="l00497"></a>00497         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> gx = 0; gx &lt; _szx; ++gx) {
<a name="l00498"></a>00498 
<a name="l00499"></a>00499                 x = ( (T)2 * gx + (T)1 ) / (T)_szx - (T)1;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> gy = 0; gy &lt; _szy; ++gy) {
<a name="l00502"></a>00502 
<a name="l00503"></a>00503                         y = ( (T)2 * gy + (T)1 ) / (T)_szy - (T)1;
<a name="l00504"></a>00504 
<a name="l00505"></a>00505                         r = (T)sqrt( x*x + y*y );
<a name="l00506"></a>00506                         <span class="keywordflow">if</span>( r &gt; (T)1 ) <span class="keywordflow">continue</span>; <span class="comment">// outside unit circle is zero</span>
<a name="l00507"></a>00507 
<a name="l00508"></a>00508                         t = (T)atan2( y, x );
<a name="l00509"></a>00509 
<a name="l00510"></a>00510                         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p = 0; p &lt;= Order; ++p) {
<a name="l00511"></a>00511 
<a name="l00512"></a>00512                                 <span class="keywordtype">int</span> qi = 0; <span class="comment">// q index: q[0, 2, 4] -&gt; qi[0, 1, 2]</span>
<a name="l00513"></a>00513 
<a name="l00514"></a>00514                                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> q = p % 2; q &lt;= p; q += 2, qi++) {
<a name="l00515"></a>00515 
<a name="l00516"></a>00516                                         _zpb[gx][gy][p][qi] = compute_V(p, q, r, t);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518                                 } <span class="comment">// q</span>
<a name="l00519"></a>00519 
<a name="l00520"></a>00520                         } <span class="comment">// p</span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522                 } <span class="comment">// gy</span>
<a name="l00523"></a>00523 
<a name="l00524"></a>00524         } <span class="comment">// gx</span>
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 }
<a name="l00534"></a>00534 <span class="comment">//=============================================================================</span>
<a name="l00535"></a>00535 } <span class="comment">// namespace zsig</span>
<a name="l00536"></a>00536 <span class="comment">//=============================================================================</span>
<a name="l00537"></a>00537 <span class="preprocessor">#endif // ZSIG_ZPOLBASIST_HH</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span><span class="comment">//=============================================================================</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="zpolbasist_8hh.html">zpolbasist.hh</a>      </li>
      <li class="footer">Generated on Thu May 26 2011 20:11:57 for zsig by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
